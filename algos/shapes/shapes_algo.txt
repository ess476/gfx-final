 ____  _                           
/ ___|| |__   __ _ _ __   ___  ___ 
\___ \| '_ \ / _` | '_ \ / _ \/ __|
 ___) | | | | (_| | |_) |  __/\__ \
|____/|_| |_|\__,_| .__/ \___||___/
                  |_|         
===============================================================================

1:
    1.1: The number of triangles on each face is equal to 2 * n^2.
    
    1.2: The normal vectors are <1, 0, 0>. This makes sense because if you cross two vectors
    that are in the YZ plane you get a vector along the X axis. Since the front face is in the
    +YZ plane, and the normal vector points away from the shape, it must have a positive x
    component.

    Note: I read the question to mean that the cube's front face is in +YZ and it's volume is behind it
    (x <= 0), (which would make sense if the camera is at a positive x value).

2:
    2.1: The equation of the circle (with r, y (the distance between the origin and the cap of the cylinder in the y direction), 
        and theta parameters and cartesian output):
        
            (x, y, z) = r(r, theta, y) = <r * cos(theta), y, r * sin(theta)>
                      = (.5 * cos(theta), y, .5 * sin(theta)),

        Note: To get locations of the vertices:
            theta = k * (2 * pi) / N
            k: [0, N - 1] (Where N is the number of vertices.)

            Note: this is N-1, not N because we don't want to repeat the first vertice. 

    2.2: 
        The surface normal of (sqrt(2) / 4, 2 / 7, -sqrt(2) / 4), it the 
        normalization of the vector of the <x, 0, z>. This is because the normal
        to a vertex on the barrel is parallel to the XZ plane.
        
        In this case it's norm(<sqrt(2) / 4, 0, -sqrt(2) / 4>), which is:
        to: <1 / sqrt(2), 0, -1 /sqrt(2)>
         
        In terms of theta: <cos(theta), 0, sin(theta)> (which doesn't need to be
        normalized, since it's magnitude will always be 1)
    

3:
    3.1:
        p1 = 1: 1
        p1 = 3: 5
        p1 = 5: 9
        p1 = 2 * (n - 1) + 1
           = 2n - 2 + 1
           = 2n - 1

    3.2: See cone.jpg in this directory.

    3.3: 
        y = mx + b:
            1. 1/2 = m(0) + b
               b = 1/2
            2. -1/2 = m(1/2) + 1/2
                -1 = m(1/2)
                -2 = m

        y = -2m + (1/2)

        m = -2

    3.4:
        -1 / m = -1 / -2 = 1 / 2

        Since the slope of a line is rise/run, the vector <1, 1/2> is along the lime with
        the slope -1/m.

        Since normalize(<1, 1/2>) = <2 / sqrt(5), 1 / sqrt(5)>,

        The magnitude of the vertical component of the normalized normal vector is: 1 / sqrt(5)

        The general formula is norm(<1, -1 / m>) = <1 / sqrt(1  + 1 / m^2), (-1 / m) / sqrt(1  + 1 / m^2)>
                                                 = <1 / sqrt(1 + (1 / m^2)), -1 / (m * sqrt(1 + (1 / m^2))>

    3.5:
        In 3.4 we found the normalized normal vector to be <2 / sqrt(5), 1 / sqrt(5)>,
        so the magnitude of the horizontal component is: 2 / sqrt(5)


4:
    4.1: 
        The normal vector at point on a sphere is just a normalized vector in the direction from the
        center of the sphere to the specified point.

        The vector from the origin to a point on the surface of a sphere is:

        r(r, phi, theta) = <r * sin(phi) * cos(theta), r * cos(phi), r * sin(phi) * sin(theta)>

        So to find the normal vector to the point at r(.5, pi / 2, pi / 4), we must evaluate
        and then normalize the result.

        r(.5, pi / 2, pi / 4) = <.5*sin(pi / 2)*cos(pi / 4), .5*cos(pi / 2), .5*sin(pi / 2)*sin(pi / 4)>
                              = <sqrt(2) / 4, 0, sqrt(2) / 4>

        norm(<sqrt(2) / 4, 0, sqrt(2) / 4>) = <sqrt(2) / 2, 0, sqrt(2) / 2>

        So the normal vector at (r, phi, theta) = (.5, pi / 2, pi / 4) is: <sqrt(2) / 2, 0, sqrt(2) / 2>


5:
    5.1: 
        If only some members are used (or make sense for your shape), you should use composition. That
        way you can prevent users from calling member functions that shouldn't ever be called on your
        shape. If you use inheritance you either have to throw a run-error indicating that the given 
        member function should not be called on this type of shape (which is really, really bad design
        for a whole lot of reasons, one being you can't catch those kinds of errors at compile time),
        or you could have the method be a dummy method which is arguably worse, or you have the method 
        fail silently in which case you probably have a bright future as a PHP engine developer.

        If all shapes use the members, then inheritance is probably fine (or rather as fine as inheritence
        is in general). You really shouldn't have members on your class that aren't implemented properly 
        or don't make logical sense. In fact the prevaling though now is to generally favor composition 
        over inheritance.


        Note: You can sort of kind of hide a member function by overriding it privately, but this only 
        prevents calling the method on the subclass not the superclass. This is arguable the worst
        possible way of shoehorning in inheritence of them all:

        For instance:

        class Shape
        {
        public:
            virtual void drawLine() { ... }
        }

        class Circle()
        {
        private:
            virtual void drawLine() { ... }
        }


        Circle c;

        c->drawLine(); // Doesn't compile.

        ((Shape) c)->drawLine(); // Calls Circle::drawLine